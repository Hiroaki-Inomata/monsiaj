全体の動作
=====
ランチャーからクライアントを生成し、スレッド上で動作させる。

ランチャーの動作
========

クラス: org.montsuqi.client.Launcher(汎用), jp.or.med.jma_receipt.JMAReceiptLauncher(日レセ専用)

1. launch()で起動。
2. 設定ダイアログを表示し、Configurationオブジェクト(conf)を生成する。
3. キャンセルならそのまま終了する。OKが押されたら、
  1. confを保存。
  2. confを用い、Clientオブジェクト(client)を生成。
  3. client.connect() でサーバに接続。
  4. スレッド上でclientを動かし(client#run())、終了を待つ。

クライアントの動作
=========

クラス: org.montsuqi.client.Client

1. conf(Configuration)の設定に従って各種パラメータを設定する。
2. connect()メソッドにより、
	1. 実際の処理を行うProtocolイオブジェクト(protocol)が生成される。
	2. protocol.sendConnect()により、サーバにユーザ名・パスワード・アプリケーション名が伝えられる。
3. 以降、終了までprotocolオブジェクトが画面要求、更新を行い続ける。

プロトコルオブジェクトの動作
==============

ここの動作はglclientのロジックをJavaに置き換えただけなので、本質的には変わるところはない。
Cコードとの対応もほぼ取れる。

1. checkScreen()により、画面定義を受け取る。タイムスタンプを比較し、古ければ取り直す。
2. getScreenData()により、クライアントが管理しているそれぞれのウィンドウについて、
	1. nodeを取得する。nodeが存在しなければ、createNode()により作成する。
	この際、取得済みの画面定義キャッシュを用いて、Interface.parseInput()により作成する。
	2. ウィンドウを必要に応じて表示する。
	3. 画面に表示すべきデータをmarshaller.receive()を使って取得する。
3. イベントを処理する。多くのイベント処理は、
	* nodeに対して、変更があったこと画面部品情報を登録する。 または
	* クライアントからアプリケーションへのイベント通知を行い、変更のあった画面データをmarshaller.send()を用いて送る。
4. 再びgetScreenData()を呼び出し、画面が更新される。以下繰り返し。
