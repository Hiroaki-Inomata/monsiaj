全体の動作
=====
ランチャーからクライアントを生成し、スレッド上で動作させる。

ランチャーの動作
========

クラス: org.montsuqi.client.Launcher(汎用), jp.or.med.jma_receipt.JMAReceiptLauncher(日レセ専用)

1. 起動。(Launcher.launch)
2. 設定ダイアログを表示し、Configurationオブジェクト(conf)を生成する。Configurationクラスは実質的にPreferences APIのラッパ。
3. キャンセルならそのまま終了する。OKが押されたら、
  1. confを保存。
  2. confを用い、Clientオブジェクト(client)を生成。
  3. サーバに接続。(client.connect)
  4. スレッド上でclientを動かし(client#run())、終了を待つ。

クライアントの動作
=========

クラス: org.montsuqi.client.Client

1. conf(Configuration)の設定に従って各種パラメータを設定する。
2. 実際の処理を行うProtocolオブジェクト(protocol)が生成される。(client.connect)
3. サーバにユーザ名・パスワード・アプリケーション名を伝える。(protocol.sendConnect)
4. 以降、終了までprotocolオブジェクトが画面要求、更新を行い続ける。

プロトコルオブジェクトの動作
==============

クラス: org.montsuqi.client.Protocol

glclientの中心的な処理をJava風に置き換えたものであり、本質的には変わるところはない。

1. 画面定義ファイルのダウンロードし、キャッシュする。(Protocol.checkScreens)
  1. QueryScreenパケットの受信により、サーバから一連の画面定義をダウンロードする。
  2. タイムスタンプとファイルサイズの比較により、不要な場合はキャッシュを利用し、ダウンロードは要求しない。
2. 表示/非表示を行う。(Protocl.showWindow)
  1. 指示された名前に対応するNodeオブジェクトを探す。
     Protocolでは、各画面はNodeクラスのインスタンスとして、画面の名前をキーとしたMapで管理されている。
     Nodeは、画面定義(Interfaceクラス)と、変更のあった画面部品の情報を管理している。
	 * 既に作成済みであれば、そのnodeを使用する。
	 * 見つからなかった場合は作成する。(Protocol.createNode/Interface.parseInput)
  2. NodeからInterfaceを得て、Windowを表示する。
  3. 続くパケットに従い、各種marshallerを用いて、表示データを取得する。(WidgetMarshaller.receive)
4. イベントを待ち、処理する。多くのイベント処理は、
  * nodeに対して、変更があったこと画面部品情報を登録する。 または
  * クライアントからアプリケーションへのイベント通知を行い、変更のあった画面データを送る。(Widgetmarshaller.send)
5. イベント処理の結果として、再びgetScreenData()が呼び出され、画面更新が続く。

画面データの取得
========
ScreenDataパケットの受信(Protocol.getScreenData)により、画面データの受信(Protocol.receiveValue)を開始する。

receiveValueでは、パケットで示されるデータ種別に応じて、
* 現在widgetName変数が示す画面部品があれば、receiveWidgetDataによって画面部品のデータを受信する。
* なければreceiveRecordValue/receiveArrayValueを使って部品名を取得していく。
* receiveWidgetDataでは、画面部品の型に対応したWidgetMarshallerを検索し、そのreceiveメソッドを使ってデータを受信する。

Interfaceの生成
============
Interfaceはgladeの画面定義をオブジェクト化した物で、画面定義ファイルから読み込む入力ストリームを
Interface.parseInputに与えて生成する。
parseInputでは

1. XMLをSAXパーザで解析して、各画面部品のデータ(WidgetInfo)のツリーを構築する。
2. buildWidgetTreeメソッドにより、再帰的に画面部品をインスタンス化する。
3. Gtk+のシグナル情報(SignalInfo)は直接利用できないので、各シグナルに対応したConnectorオブジェクトを用いて、
Swingのイベントオブジェクト/イベントリスナの対として関連づける。
4. 生成されたInterfaceインスタンスと、画面を実体化した際の変更がなされた画面部品テーブルをまとめて、Nodeインスタンスを
生成する。

以上の処理の結果得られたNodeを用いてProtocolオブジェクトがイベント処理・データ通信を行う。
